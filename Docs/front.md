# Front-end

### 리액트

리액트는 왜 쓸까? 꽤 많은 이유가 있겠지만 결론만 말하자면 생산성 뿐만 아니라 퍼포먼스도 올라가기 때문이다. 리액트가 아니더라도 최신 트랜드 기술들의 초점은 거의 대부분은 높은 생산성과 퍼포먼스, 낮은 러닝커브에 맞춰져 있다. 그럼에도 리액트의 장점을 분석해보자면,

1. UI들이 컴포넌트라는 조각으로 이뤄져있어 코드 재활용 측면에서 우수하다.
2. 분할정복 개념이 내재되어 있어 복잡한 UI를 설계할 때 편리하고 코드를 읽을 때도 편하다.
3. JSX라는 문법으로 빈 html에 js만 갈아끼는 원리이기 때문에 기존 돔 요소를 가져와서 조작하는 일련의 과정이 상당히 축소된다.
4. Virtual DOM으로 변경된 부분만 리렌더링 할 수 있다.
5. functional component, hook의 등장으로 러닝커브가 상당히 줄어들었다.

<br/>

### Virtual DOM

리액트 공식문서에선 Virtual DOM을 UI의 이상적인 또한 '가상'적인 표현을 메모리에 저장하고 '실제' 돔과 동기화하는 프로그래밍 개념이라고 소개한다. 이 과정을 재조정(Reconciliation)이라 부른다. 그리고 흔히 우리는 Virtual DOM이 있기 때문에 변경된 부분만 리렌더링 될 수 있다고 말한다.

state나 props가 갱신되면 render() 함수는 새로운 엘리먼트 트리를 반환한다. 새롭게 만들어진 가상 돔은 이전 가상 돔과 비교(diffing)해서 바뀐 부분을 찾는다. 가상 돔은 어떻게 이전 가상 돔과 비교해서 바뀐 부분을 찾을까? 최첨단 알고리즘도 n개의 엘리먼트가 있는 트리에 대해 O(n^3) 의 복잡도를 가진다고 말한다. 너무나 비싼 연산이다. 가상 돔은 이렇게 작동하지 않는다. 대신 두 가지 가정을 하여 O(n) 복잡도의 휴리스틱 알고리즘을 구현했다.

1. 서로 다른 타입의 두 엘리먼트는 서로 다른 트리를 만들어낸다.
2. key prop을 통해 여러 렌더링 사이에서 어떤 자식 엘리먼트가 변경되지 않아야 할지 표시해줄 수 있다.

이전 가상돔과 현재 가상돔을 비교할 때에는 루트 엘리먼트부터 비교한다. 비교를 하며 두 DOM의 엘리먼트 타입이 다르다면 그 밑에 있는 모든 컴포넌트에 대해 트리를 재구축하게 된다. 엘리먼트 타입이 같다면 두 엘리먼트의 속성을 비교하여 변경된 속상만 갱신한다.

리스트와 같은 반복되는 엘리먼트는 key prop이 필요하다. key가 없을 때에는 변경되지 않은 엘리먼트가 리렌더링되지 않을 것임을 전혀 보장해주지 못한다. 이 알고리즘은 엘리먼트들의 순서만 달라져도 모든 엘리먼트들이 달라졌다고 판단할 것이다. 주의할 점은 배열의 인덱스를 key로 사용하면 항목의 순서가 바뀔 때 key도 변경될 것이다. 리액트 인스턴스는 key를 기반으로 갱신되기 때문에 항목의 순서가 바뀌면 의도하지 않은 방식으로 렌더링될 수 있다.

<br/>

### npx vs npm의 차이

원래는 create-react-app을 할 때 npm install -g create-react-app을 통해 내 컴퓨터에 설치해야했지만 npx를 이용하면 내 컴퓨터에 설치할 필요없이 npm 레지스트리에서 create-react-app을 찾아서 실행시켜준다. 이렇게 되면 내 디스크 용량을 잡아먹지도 않을 뿐더러 항상 최신 버전의 cra를 이용할 수 있다.

### CORS 정책 이슈, Proxy 설정

CORS (cross-origin resource sharing) 은 추가 http 해더를 사용해서 한 출처에서 실행 중인 웹 애플리케이션이 다른 출처의 선택한 자원에 접근할 수 있는 권한을 부여하도록 브라우저에 알려주는 체제이다. 웹 애플리케이션은 리소스가 자신의 출처와 다를 때 교차 출처 http 요청을 실행한다. 이때 출처라는 것은 포트를 포함한다.

예를들어 localhost:3000 에서 XMLHttpRequest 혹은 fetch 를 이용해서 localhost:4000에 리소소를 요청하면 보안 상의 이유로 브라우저는 교차 출처 http 요청을 제한한다. 즉 웹 애플리케이션은 자신의 출처와 동일한 리소스만 불러올 수 있는 것이다. 다른 출처의 리소스를 불러오려면 그 출처에서 올바른 cors 헤더를 포함한 응답을 반환해야 한다.

CORS 정책에 위배되는 경우 다양한게 해결할 수 있다.

1. 개발자 도구를 이용할 수 있음. 하지만 개발자들만 사용하는 것일뿐
2. 프론트엔드에서 해결해야 한다면? JSONP 를 이용할 수 있다 (추가적인 공부 필요)
3. 백엔드 프론트 모두 고칠 수 있다면? 서버에서 클라이언트에서 오는 것을 받을 수 있게 하고 클라이언트에서도 보낼 때 이런 것들을 허락해달라는 요청을 하면 된다.(마찬가지로 추가적인 공부 필요...)
4. 프록시 서버를 이용하는 방법

이번에는 프록시 서버를 이용하여 cors 위배를 해결할 것이다.

프록시 서버는 클라이언트가 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템을 가리킨다. 서버와 클라이언트 사이에 중계기로서 대리로 통신을 수행하는 것이다.

추가적인 공부가 필요하겠지만 일단 프록시를 이용하면 클라이언트의 출처를 프록시 서버에서 임의로 바꾸어 버릴 수 있다. 그럼 프록시에서 내 출처를 내 서버의 origin으로 변경하면 cors 정책에 위배되지 않는다.

### concurrently

백 서버와 클라이언트 서버를 동시에 킬 수 있게 해주는 패키지이다. 명령어를 입력할 package.json 이 있는 곳에서 설치하고, 개발 중에만 이용할 것이기 때문에 개발 의존성 모듈로 설치하자.

```
$ npm i -D concurrently
```

### React-query

### Recoil
