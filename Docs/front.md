# Front-end

### 리액트

리액트는 왜 쓸까? 꽤 많은 이유가 있겠지만 결론만 말하자면 생산성 뿐만 아니라 퍼포먼스도 올라가기 때문이다. 리액트가 아니더라도 최신 트랜드 기술들의 초점은 거의 대부분은 높은 생산성과 퍼포먼스, 낮은 러닝커브에 맞춰져 있다. 그럼에도 리액트의 장점을 분석해보자면,

1. UI들이 컴포넌트라는 조각으로 이뤄져있어 코드 재활용 측면에서 우수하다.
2. 분할정복 개념이 내재되어 있어 복잡한 UI를 설계할 때 편리하고 코드를 읽을 때도 편하다.
3. JSX라는 문법으로 빈 html에 js만 갈아끼는 원리이기 때문에 기존 돔 요소를 가져와서 조작하는 일련의 과정이 상당히 축소된다.
4. Virtual DOM으로 변경된 부분만 리렌더링 할 수 있다.
5. functional component, hook의 등장으로 러닝커브가 상당히 줄어들었다.

<br/>

### Virtual DOM

리액트 공식문서에선 Virtual DOM을 UI의 이상적인 또한 '가상'적인 표현을 메모리에 저장하고 '실제' 돔과 동기화하는 프로그래밍 개념이라고 소개한다. 이 과정을 재조정(Reconciliation)이라 부른다. 그리고 흔히 우리는 Virtual DOM이 있기 때문에 변경된 부분만 리렌더링 될 수 있다고 말한다.

state나 props가 갱신되면 render() 함수는 새로운 엘리먼트 트리를 반환한다. 새롭게 만들어진 가상 돔은 이전 가상 돔과 비교(diffing)해서 바뀐 부분을 찾는다. 가상 돔은 어떻게 이전 가상 돔과 비교해서 바뀐 부분을 찾을까? 최첨단 알고리즘도 n개의 엘리먼트가 있는 트리에 대해 O(n^3) 의 복잡도를 가진다고 말한다. 너무나 비싼 연산이다. 가상 돔은 이렇게 작동하지 않는다. 대신 두 가지 가정을 하여 O(n) 복잡도의 휴리스틱 알고리즘을 구현했다.

1. 서로 다른 타입의 두 엘리먼트는 서로 다른 트리를 만들어낸다.
2. key prop을 통해 여러 렌더링 사이에서 어떤 자식 엘리먼트가 변경되지 않아야 할지 표시해줄 수 있다.

이전 가상돔과 현재 가상돔을 비교할 때에는 루트 엘리먼트부터 비교한다. 비교를 하며 두 DOM의 엘리먼트 타입이 다르다면 그 밑에 있는 모든 컴포넌트에 대해 트리를 재구축하게 된다. 엘리먼트 타입이 같다면 두 엘리먼트의 속성을 비교하여 변경된 속상만 갱신한다.

리스트와 같은 반복되는 엘리먼트는 key prop이 필요하다. key가 없을 때에는 변경되지 않은 엘리먼트가 리렌더링되지 않을 것임을 전혀 보장해주지 못한다. 이 알고리즘은 엘리먼트들의 순서만 달라져도 모든 엘리먼트들이 달라졌다고 판단할 것이다. 주의할 점은 배열의 인덱스를 key로 사용하면 항목의 순서가 바뀔 때 key도 변경될 것이다. 리액트 인스턴스는 key를 기반으로 갱신되기 때문에 항목의 순서가 바뀌면 의도하지 않은 방식으로 렌더링될 수 있다.

<br/>

### npx vs npm의 차이

원래는 create-react-app을 할 때 npm install -g create-react-app을 통해 내 컴퓨터에 설치해야했지만 npx를 이용하면 내 컴퓨터에 설치할 필요없이 npm 레지스트리에서 create-react-app을 찾아서 실행시켜준다. 이렇게 되면 내 디스크 용량을 잡아먹지도 않을 뿐더러 항상 최신 버전의 cra를 이용할 수 있다.
